# State

## original

[original/state1.cpp](./original/state1.cpp)存在如下问题

如果`NetworkState`多了一个状态`Network_Wait`，则需要修改`OperationX()`函数的实现，在其中添加相应的`else`分支，这违背了`开闭原则`

`OperationX()`函数的数量是稳定的，在这里个例子中，有3个`OperationX()`函数。

## refactored

每个状态抽象成一个独立的类，并在在一个状态中只关注它当前要做的行为和下一个要转换到的状态

## State与Strategy对比

State模式和Strategy模式都是用于解决对象中某些行为的灵活性和可扩展性问题。

State模式主要用于解决**对象状态变化**的问题。比如一个订单对象可能有多种状态，如待处理、已发货、已完成等等。不同状态下订单对象的行为也不同，比如待处理状态下可以取消订单，已发货状态下可以查看物流信息等。State模式通过将订单状态抽象成一个独立的类，并将状态的变化封装在状态类中，从而实现状态的可扩展性和灵活性。

Strategy模式主要用于解决**对象算法变化**的问题。比如一个支付对象可能有多种支付方式，如支付宝、微信、银行卡等等。不同支付方式下支付对象的行为也不同，比如支付宝支付方式下需要调用支付宝接口完成支付，银行卡支付方式下需要调用银行接口完成支付等。Strategy模式通过将支付方式抽象成一个独立的类，并将支付方式的实现封装在支付方式类中，从而实现支付方式的可扩展性和灵活性。

Strategy模式并不是State模式的特例：

在Strategy模式中，算法的实现是独立的，它们可以在运行时动态地替换，而不会影响到客户端代码。而在State模式中，状态的变化和状态行为的实现是紧密耦合的，状态的变化会影响到状态行为的实现。因此，Strategy模式更加关注算法的实现，而State模式更加关注状态的变化。

另外，在Strategy模式中，客户端通常需要显式地指定使用哪种算法，而在State模式中，客户端只需要调用对象的行为方法，对象会自动根据当前状态来执行相应的行为。因此，Strategy模式更加灵活，但需要客户端具有更多的控制权，而State模式更加简单，但对客户端的要求更低。
